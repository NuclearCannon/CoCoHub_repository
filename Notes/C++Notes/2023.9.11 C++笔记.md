2023.9.11 C++笔记

private：私有，只能被本类的成员访问
protected：只能被本类和本类的派生类访问
public：谁都可以访问

不写构造函数，可以，但是不推荐
构造函数起到对对象占据的空间进行初始化的作用，但不是分配其空间
（此处空间指的是“体内空间”，直接占据的空间，sizeof能统计出来的空间，不包括其成员的指针分配的空间等）
写构造函数使得初始化更简单
若不写构造函数，编译器会自动生成一个

<!--more-->

构造函数：

- 可以有多个，可以不定义
  如一个构造函数都没写，编译器会生成一个默认无参构造函数
  （等一下，它的具体行为是？）
  （会帮我初始化成员对象吗？）
  （答：什么都不做，成员初始化都不做）
  如果写了构造函数，编译器不会再提供此默认构造函数
- 函数名与类名相同
- 多种参数，可以重载
- 无返回类型，连void也没有
- 只能自动调用，不能手动A.ClassName()调用
- ？？？

什么时候会使用一个对象调用另一个对象？

- Student zhang = xu;
- 直接传参，如
  void myfun(Student a){...}
  myfun(xu);
  参数传递时等同于a=xu;
  （Student zhang = xu和Student zhang(xu)有什么区别？）
  （Student zhang = {...}和Student zhang(...)有什么区别？）
- 以返回一个对象时：
  return StudentA;
  即使不接受这个返回值，
  StudentA的值会被赋值给一个临时空间（需要实验）
  然后马上被析构（无用功）

默认的拷贝构造函数是一个以有址引用为参数的构造函数

Student stu2(stu1);

简单地将stu1的内容拷贝到stu2的空间中，这是一种浅拷贝
如果没有体外空间，这种构造函数是存在风险的（两个对象使用同一个体外空间）

自己写构造函数

```c++
Student::Student(const Student& s)
{
    //...
}
```

为何要加一个const？
场景1：

```c++
const Student unchange = { "XXXX", 100, 100, "unchange"};
Student xu = unchange;//构造函数没有const

```

报错：编译器会怀疑xu构造时会改变unchange（虽然实际上你可能没改），但是unchange是不可改的
不能把一个const对象的地址送给一个非const的引用

场景2

```c++
Student CreateStudent()
{
    Student temp("temp",0,0,NULL);
    return temp;
}
//...
Student a = CreateStudent();
```

报错：Student没有适当的复制构造函数。
相当于a=temp，但是return时使用的临时变量被认为是const的。

const只在编译器语法检查时出现，exe里面不会存在const这种东西
使用引用参数和使用指针没有本质区别

以对象为参数的构造函数的缺陷：
return的临时变量还要释放，浪费

解决方案是移动构造

```c++
Student::Student(Student&& s)
{
	...
	remark = s.remark;//remark是一个指针，直接复制指针，重复利用体外空间
	s.remark = NULL;//避免被析构
}
```

这两个函数都可以适配return，但是编译器认为第二个更合适，它自己会选择
（等一下，它怎么选择的？）



析构函数：用来释放体外空间的函数

- 析构函数只有一个
- 没有体外空间的时候，析构函数没必要定义









数据的存储表示和地址

程序是怎么分配变量的地址的？传参具体怎么传？
不同的编译器可能对此有不同的解释
原本我们不需要关注这种东西，但是，现在我们需要

访问越界越到哪去了？我能不能找到？

C/C++  代码生成 基本运行时检查 默认值
这样空间分配是紧凑的
才会出现a[-1]等价于x之类的事情
 VS到底做了什么工作？才会发生这种事情？

基本运行时检查：堆栈帧，未初始化的变量

何时进行越界检查？
如何进行越界检查
能否发生了越界而系统检查不出来？
在没有检测时，数组越界会不会导致程序崩溃？

CPU保护机制：程序运行的时候，使用的必须是给他的空间而非别人的空间

未初始化的变量检测：

```c++
int x,y;
y=x; //编译报错：使用了未初始化的局部变量x
```

但是

```c++
int x,y;
if(...)x=10;
y=x;//难说
```

能判断出来到底也没有没有初始化

编译器设置了一个影子变量，用于表示变量是否被初始化。
若执行了赋值，则影子变量为1.
若使用变量时影子变量为0，则报错

函数返回局部地址：

```c++
#include <iostream> 
char* f()
{
    char temp[20];
    strcpy_s(temp, "hello");
    return temp;
}
int main()
{
    char* p;
    char a[20];
    int  i=0;
    p = f();
    while (*(p + i) != 0) {
        a[i] = p[i];
        i++;
    }
    a[i] = 0;
    printf("%s \n", a);
    printf("%s \n", p);
    return 0;
}
```

temp虽然被释放了，但是上面的内容没有被清楚，因此a可以正常输出。
但是p打印的时候就不能打印出hello，等一下，为什么？

在printf(a)之前，p仍然指向hello
在printf(a)之后，p虽然还指向那个位置，但是东西已经变了，不是hello了

内存泄漏检测方法……？

